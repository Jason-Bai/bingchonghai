// Generated by CoffeeScript 1.10.0
(function() {
  var _, async, cache, cacheKey, client, del, flush, get, getKey, namespace, redis, set,
    slice = [].slice;

  redis = require('redis');

  _ = require('underscore');

  async = require('async');

  client = null;

  namespace = '';

  getKey = function(key) {
    return namespace + "::" + key;
  };

  get = function(key, callback) {
    key = getKey(key);
    return client.get(key, function(error, result) {
      if (error) {
        return callback(error);
      }
      return callback(null, JSON.parse(result));
    });
  };

  set = function(key, value, life, callback) {
    key = getKey(key);
    return client.set(key, JSON.stringify(value), function(error) {
      if (typeof callback === "function") {
        callback(error);
      }
      if (!life) {
        return;
      }
      return client.expire([key, +life || 1], function(error) {
        if (error) {
          return console.error(error);
        }
      });
    });
  };

  flush = function(key, callback) {
    return client.keys(getKey(key), function(error, list) {
      if (error) {
        return callback(error);
      }
      return async.each(list, client.del.bind(client), callback);
    });
  };

  del = function(key, callback) {
    if (callback == null) {
      callback = console.error;
    }
    key = getKey(key);
    return client.del(key, callback);
  };


  /*
   * 只为cache 函数使用，用来根据用户执行函数的参数中获取到cache的key
   * 有别于getKey
   */

  cacheKey = function(tpl, args) {
    var regxp;
    regxp = /\{(\d+)\}/g;
    if (!regxp.test(tpl)) {
      return tpl;
    }
    return tpl.replace(regxp, function(m, i) {
      return args[i];
    });
  };

  cache = function(keyTpl, func, life, bind) {
    var fn;
    if (!client) {
      throw Error('cache must be init, at use before');
    }
    fn = function() {
      var args, callback, j, key;
      args = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), callback = arguments[j++];
      if (!_.isFunction(callback)) {
        throw "Callback function non-exists";
      }
      key = cacheKey(keyTpl, args);
      return get(key, function(error, result) {
        if (error) {
          console.error(error);
        }
        if (!error && result) {
          return callback(null, result);
        }
        args.push(function(error, result) {
          if (error) {
            return callback(error, result);
          }
          set(key, result, life);
          return callback(error, result);
        });
        return func.apply(bind, args);
      });
    };
    fn.removeKey = function() {
      var args, callback, j;
      args = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), callback = arguments[j++];
      if (callback == null) {
        callback = console.error;
      }
      return del(cacheKey(keyTpl, args), callback);
    };
    return fn;
  };

  cache.init = function(port, ip, opts) {
    if (port == null) {
      port = 6379;
    }
    if (ip == null) {
      ip = '127.0.0.1';
    }
    if (client) {
      return;
    }
    namespace = opts && opts.namespace || '';
    client = redis.createClient(port, ip, opts && opts.redis);
    client.on('error', function(error) {
      return console.error(error);
    });
    cache.get = get;
    cache.set = set;
    cache.del = del;
    cache.flush = flush;
    return cache.client = client;
  };

  cache.get = cache.set = cache.del = function() {
    throw Error('cache must be init, at use before');
  };

  module.exports = cache;

}).call(this);
